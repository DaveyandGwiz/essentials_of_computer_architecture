REVIEW OF ESSENTIAL TERMS
 AND CONCEPTS

 1. Explain the difference between register-to-register, register-to
memory, and memory-to-memory instructions.




 2. Several design decisions exist with regard to instruction sets. Name
 four and explain.

a) number of insrtuctions
A smaller number inplies less bits for the opcode and hence less memory usage
However, this also means less instructions
b) Instruction size
Larger sizes imply a longer execution cycle.
But less possible operations
c) 

 3. What is an expanding opcode?

 4. If a byte-addressable machine with 32-bit words stores the hex value
 98765432, indicate how this value would be stored on a little endian
 machine and on a big endian machine. Why does “endian-ness”
 matter?

 5. We can design stack architectures, accumulator architectures, or
 general-purpose register architectures. Explain the differences
 between these choices and give some situations where one might be
 better than another.

 6. How do memory-memory, register-memory, and load-store
 architectures differ? How are they the same?

 7. What are the pros and cons of fixed-length and variable-length
 instructions? Which is currently more popular?

 8. How does an architecture based on zero operands ever get any data
 values from memory?

 9. Which is likely to be longer (have more instructions): a program
 written for a zero-address architecture, a program written for a one
address architecture, or a program written for a two-address
 architecture? Why?

 10. Why might stack architectures represent arithmetic expressions in
 reverse Polish notation?

 11. Name the seven types of data instructions and explain each.

12. What is the difference between an arithmetic shift and a logical shift?

 13. Explain what it means for an instruction set to be orthogonal.

 14. What is an address mode?

 15. Give examples of immediate, direct, register, indirect, register
 indirect, and indexed addressing.

 16. How does indexed addressing differ from based addressing?

 17. Why do we need so many different addressing modes?

 18. Explain the concept behind instruction pipelining.

 19. What is the theoretical speedup for a four-stage pipeline with a 20ns
 clock cycle if it is processing 100 tasks?

 20. What are the pipeline conflicts that can cause a slowdown in the
 pipeline?

 21. What are the two types of ILP, and how do they differ?

 22. Explain superscalar, superpipelining, and VLIW architectures.

 23. List several ways in which the Intel and MIPS ISAs differ. Name
 several ways in which they are the same.

 24. Explain Java bytecodes.

 25. Give an example of a current stack-based architecture and a current
 GPR-based architecture. How do they differ?
